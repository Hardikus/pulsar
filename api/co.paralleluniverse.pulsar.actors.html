<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>co.paralleluniverse.pulsar.actors documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Pulsar 0.6.1 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li class="current"><a href="co.paralleluniverse.pulsar.actors.html"><span>co.paralleluniverse.pulsar.actors</span></a></li><li><a href="co.paralleluniverse.pulsar.async.html"><span>co.paralleluniverse.pulsar.async</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html"><span>co.paralleluniverse.pulsar.core</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html"><span>co.paralleluniverse.pulsar.lazyseq</span></a></li><li><a href="co.paralleluniverse.pulsar.rx.html"><span>co.paralleluniverse.pulsar.rx</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="co.paralleluniverse.pulsar.actors.html#var-%21"><span>!</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-%21%21"><span>!!</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var--%3EPulsarEventHandler"><span>-&gt;PulsarEventHandler</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-actor"><span>actor</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-call%21"><span>call!</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-call-timed%21"><span>call-timed!</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-cast%21"><span>cast!</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-defactor"><span>defactor</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-done%3F"><span>done?</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-gen-event"><span>gen-event</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-gen-server"><span>gen-server</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-get-child"><span>get-child</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-link%21"><span>link!</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-mailbox"><span>mailbox</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-mailbox-of"><span>mailbox-of</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-maketag"><span>maketag</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-receive"><span>receive</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-recur-swap"><span>recur-swap</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-register%21"><span>register!</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-remove-and-terminate-child%21"><span>remove-and-terminate-child!</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-reply%21"><span>reply!</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-reply-error%21"><span>reply-error!</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-self"><span>self</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-set-state%21"><span>set-state!</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-set-timeout%21"><span>set-timeout!</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-shutdown%21"><span>shutdown!</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-spawn"><span>spawn</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-spawn-link"><span>spawn-link</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-state"><span>state</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-supervisor"><span>supervisor</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-trap%21"><span>trap!</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-unlink%21"><span>unlink!</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-unregister%21"><span>unregister!</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-unwatch%21"><span>unwatch!</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-vref"><span>vref</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-watch%21"><span>watch!</span></a></li><li><a href="co.paralleluniverse.pulsar.actors.html#var-whereis"><span>whereis</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>co.paralleluniverse.pulsar.actors documentation</h2><pre class="doc">Defines actors and behaviors like gen-server and supervisor
</pre><div class="public" id="var-%21"><h3>!</h3><h4 class="macro">macro</h4><div class="usage"><code>(! actor message)</code><code>(! actor arg &amp; args)</code></div><pre class="doc">Sends a message to an actor.
This function returns `nil`.
If the actor's mailbox capacity has been exceeded, this function's behavior
is determined by the `overflow-policy` set by the receiving actor's `spawn`.

See: `spawn`</pre></div><div class="public" id="var-%21%21"><h3>!!</h3><h4 class="macro">macro</h4><div class="usage"><code>(!! actor message)</code><code>(!! actor arg &amp; args)</code></div><pre class="doc">Sends a message to an actor synchronously.
This has the exact same semantics as !, but hints to the scheduler that the 
current actor is about to wait for a response from the message's addressee.

See: `!`</pre></div><div class="public" id="var--%3EPulsarEventHandler"><h3>-&gt;PulsarEventHandler</h3><div class="usage"><code>(-&gt;PulsarEventHandler handler)</code></div><pre class="doc">Positional factory function for class co.paralleluniverse.pulsar.actors.PulsarEventHandler.
</pre></div><div class="public" id="var-actor"><h3>actor</h3><h4 class="macro">macro</h4><div class="usage"><code>(actor bindings &amp; body)</code></div><pre class="doc">Creates a new actor.
</pre></div><div class="public" id="var-call%21"><h3>call!</h3><div class="usage"><code>(call! gs m)</code><code>(call! gs m &amp; args)</code></div><pre class="doc">Makes a synchronous call to a gen-server and returns the response
</pre></div><div class="public" id="var-call-timed%21"><h3>call-timed!</h3><div class="usage"><code>(call-timed! gs timeout unit m)</code><code>(call-timed! gs timeout unit m &amp; args)</code></div><pre class="doc">Makes a synchronous call to a gen-server and returns the response
</pre></div><div class="public" id="var-cast%21"><h3>cast!</h3><div class="usage"><code>(cast! gs m)</code><code>(cast! gs m &amp; args)</code></div><pre class="doc">Makes an asynchronous call to a gen-server
</pre></div><div class="public" id="var-defactor"><h3>defactor</h3><h4 class="macro">macro</h4><div class="usage"><code>(defactor name doc-string? attr-map? [params*] body)</code></div><pre class="doc">Defines a new actor template.
</pre></div><div class="public" id="var-done%3F"><h3>done?</h3><div class="usage"><code>(done? a)</code></div><pre class="doc">Tests whether or not an actor has terminated.
</pre></div><div class="public" id="var-gen-event"><h3>gen-event</h3><div class="usage"><code>(gen-event :name? :timeout? :mailbox-size? :overflow-policy? server &amp; args)</code></div><pre class="doc">Creates (but doesn't start) a new gen-event
</pre></div><div class="public" id="var-gen-server"><h3>gen-server</h3><h4 class="macro">macro</h4><div class="usage"><code>(gen-server :name? :timeout? :mailbox-size? :overflow-policy? server &amp; args)</code></div><pre class="doc">Creates (but doesn't start) a new gen-server
</pre></div><div class="public" id="var-get-child"><h3>get-child</h3><div class="usage"><code>(get-child sup id)</code></div><pre class="doc">Returns a supervisor's child by id
</pre></div><div class="public" id="var-link%21"><h3>link!</h3><div class="usage"><code>(link! actor2)</code><code>(link! actor1 actor2)</code></div><pre class="doc">Links two actors. If only one actor is specified, links the current actor with the
specified actor.

A link is symmetrical. When two actors are linked, when one of them dies, the other throws 
a `co.paralleluniverse.actors.LifecycleException` exception which, unless caught, kills it 
as well.
If `:trap true` was added to the actor's `spawn` call, or if `(trap!)` has been called by
the actor, rather than an exception being thrown, an exit message is sent to the actor.
The message is of the same structure as the one sent as a result of `watch!` except that
the watch element is `nil`.

See: `unlink!`, `watch!`</pre></div><div class="public" id="var-mailbox"><h3>mailbox</h3><div class="usage"></div><pre class="doc">@mailbox is the mailbox channel of the currently running actor
</pre></div><div class="public" id="var-mailbox-of"><h3>mailbox-of</h3><div class="usage"><code>(mailbox-of actor)</code></div><pre class="doc">Returns the mailbox of the given actor.
</pre></div><div class="public" id="var-maketag"><h3>maketag</h3><div class="usage"><code>(maketag)</code></div><pre class="doc">Returns a random, probably unique, identifier.
(this is similar to Erlang's makeref).</pre></div><div class="public" id="var-receive"><h3>receive</h3><h4 class="macro">macro</h4><div class="usage"><code>(receive)</code><code>(receive patterns* &lt;:after ms action&gt;?)</code><code>(receive [binding transformation?] patterns* &lt;:after ms action&gt;?)</code></div><pre class="doc">Receives a message in the current actor and processes it.

Receive performs pattern matching (with free var binding) on the message.
Example:
  (let [actor (spawn
               #(receive
                   :abc &quot;yes!&quot;
                   [:why? answer] answer
                   :else &quot;oy&quot;))]
     (! actor [:why? &quot;because!&quot;])
     (join actor)) ; =&gt; &quot;because!&quot;

`receive` performs a *selective receive*. If the next message in the mailbox does
not match any of the patterns (and an `:else` clause is not present), it is skipped, 
and the next message will be attempted.
`receive` will block until a matching message arrives, and will return the value of
the matching clause.

Skipped messages are not discarded, but are left in the mailbox. Every call to `receive` 
will attempt to match any message in the mailbox, starting with the oldest. 
(Skipped messages migh accumulate in the mailbox if not matched, so it's good practice
to at least occasionally call a `receive` that has an `:else` clause.)

If the first element of the `receive` expression is a vector, it is used for binding:
The vector's first element is the name assigned to the entire message, and the second,
if it exists, is a transformation function, of one argument, that will be applied to 
the message before binding and before pattern-matching:

   (receive [m transform]
     [:foo val] (println &quot;got foo:&quot; val)
     :else      (println &quot;got&quot; m))

 Now `m` – and the value we're matching – is the the transformed value.

A timeout in milliseconds, may be specified in an `:after` clause, which must appear last:

  (receive [m transform]
     [:foo val] (println &quot;got foo:&quot; val)
     :else      (println &quot;got&quot; m)
     :after 30  (println &quot;nothing...&quot;))

`receive` may be called without parameters, in which case it will indefinitely wait for
the next (without any selection) message and return it. For a non-selective receive with
a timeout, use `timed-receive`.</pre></div><div class="public" id="var-recur-swap"><h3>recur-swap</h3><h4 class="macro">macro</h4><div class="usage"><code>(recur-swap f &amp; args)</code></div><pre class="doc">Recurs to `f` (which is the actor function), checking for possible hot code swaps
and applying them.</pre></div><div class="public" id="var-register%21"><h3>register!</h3><div class="usage"><code>(register! actor-name actor)</code><code>(register! actor-or-name)</code><code>(register!)</code></div><pre class="doc">Registers an actor in the actor registry.
The actor is registered by its name, or, if it doesn't have a name, one must be supplied
to this function. The name can be a string or a keyword, in which case it's identical to the 
keyword's name (i.e. a name of `&quot;foo&quot;` is the same as `:foo`).</pre></div><div class="public" id="var-remove-and-terminate-child%21"><h3>remove-and-terminate-child!</h3><div class="usage"><code>(remove-and-terminate-child! supervisor id)</code></div><pre class="doc">Removes an actor from a supervisor and terminates the actor
</pre></div><div class="public" id="var-reply%21"><h3>reply!</h3><div class="usage"><code>(reply! to id res)</code></div><pre class="doc">Replies to a message sent to the current gen-server
</pre></div><div class="public" id="var-reply-error%21"><h3>reply-error!</h3><div class="usage"><code>(reply-error! to id error)</code></div><pre class="doc">Replies with an error to a message sent to the current gen-server
</pre></div><div class="public" id="var-self"><h3>self</h3><div class="usage"></div><pre class="doc">@self is the currently running actor
</pre></div><div class="public" id="var-set-state%21"><h3>set-state!</h3><div class="usage"><code>(set-state! x)</code></div><pre class="doc">Sets the state of the currently running actor.
The state can be read with `@state`.</pre></div><div class="public" id="var-set-timeout%21"><h3>set-timeout!</h3><div class="usage"><code>(set-timeout! timeout unit)</code></div><pre class="doc">Sets the timeout for the current gen-server
</pre></div><div class="public" id="var-shutdown%21"><h3>shutdown!</h3><div class="usage"><code>(shutdown! gs)</code><code>(shutdown!)</code></div><pre class="doc">Asks a gen-server or a supervisor to shut down
</pre></div><div class="public" id="var-spawn"><h3>spawn</h3><h4 class="macro">macro</h4><div class="usage"><code>(spawn :name? :mailbox-size? :overflow-policy? :lifecycle-handler? :stack-size? :pool? f &amp; args)</code></div><pre class="doc">Creates and starts a new actor running in its own, newly-spawned fiber.

f - the actor function.
args - (optional) arguments to for the function.

Options:
* `:name` - The actor's name (that's also given to the fiber running the actor). The name can be a string
            or a keyword, in which case it's identical to the keyword's name (i.e. a name of `&quot;foo&quot;` is the same as `:foo`).
* `:mailbox-size` - The number of messages that can wait in the mailbox, 
                    or -1 (the default) for an unbounded mailbox.
* `:overflow-policy` - What to do if a bounded mailbox overflows. Can be on of:
   - `:throw` - an exception will be thrown *into the receiving actor*
   - `:drop`  -  the message will be silently discarded 
   - `:block` - the sender will block until there's room in the mailbox.  
* `:trap` - If set to `true`, linked actors' death will send an exit message rather than throw an exception.
* `:lifecycle-handle` - A function that will be called to handle special messages sent to the actor. 
                        If set to `nil` (the default), the default handler is used, which is what you 
                        want in all circumstances, except for some actors that are meant to do some 
                        special tricks.
* `:scheduler` - The `FiberScheduler` in which the fiber will run.
               If `:fj-pool` is not specified, then the pool used will be either the pool of the fiber calling 
               `spawn-fiber`, or, if `spawn-fiber` is not called from within a fiber, a default pool.
* `:stack-size` - The initial fiber stack size.</pre></div><div class="public" id="var-spawn-link"><h3>spawn-link</h3><h4 class="macro">macro</h4><div class="usage"><code>(spawn-link :name? :mailbox-size? :overflow-policy? :lifecycle-handler? :stack-size? :pool? f &amp; args)</code></div><pre class="doc">Creates and starts, as by `spawn`, a new actor, and links it to @self.

See: `link!`</pre></div><div class="public" id="var-state"><h3>state</h3><div class="usage"></div><pre class="doc">@state is the state of the currently running actor.
The state can be set with `set-state!`</pre></div><div class="public" id="var-supervisor"><h3>supervisor</h3><div class="usage"><code>(supervisor name restart-strategy init)</code><code>(supervisor restart-strategy init)</code></div><pre class="doc">Creates (but doesn't start) a new supervisor
</pre></div><div class="public" id="var-trap%21"><h3>trap!</h3><div class="usage"><code>(trap!)</code></div><pre class="doc">Sets the current actor to trap lifecycle events (like a dead linked actor) 
and turn them into exit messages.
Same as adding `:trap true` to `spawn`.</pre></div><div class="public" id="var-unlink%21"><h3>unlink!</h3><div class="usage"><code>(unlink! actor2)</code><code>(unlink! actor1 actor2)</code></div><pre class="doc">Unlinks two actors. If only one actor is specified, unlinks the current actor from the
specified actor.

See: `link!`</pre></div><div class="public" id="var-unregister%21"><h3>unregister!</h3><div class="usage"><code>(unregister! x)</code><code>(unregister!)</code></div><pre class="doc">Unregisters an actor.

If no argument is supplied, unregisters the current actor.</pre></div><div class="public" id="var-unwatch%21"><h3>unwatch!</h3><div class="usage"><code>(unwatch! actor2 monitor)</code></div><pre class="doc">Makes an actor stop watching another actor
</pre></div><div class="public" id="var-vref"><h3>vref</h3><div class="usage"><code>(vref x)</code></div><pre class="doc">Turns a value into an IDeref (makes it deref-able)
</pre></div><div class="public" id="var-watch%21"><h3>watch!</h3><div class="usage"><code>(watch! actor)</code></div><pre class="doc">Makes the current actor watch another actor. Returns a watch object which is then
used in all relevant exit messages, and should also be used when calling `unwatch!`.

Unlike links, watches are assymetrical. If a the watched actor dies, the watching 
actor (the actor calling this function), receives an exit message. 

The message is a vector of 4 elements, of the following structure:

[:exit w actor cause]

`w` - the watch object returned from the call to `watch!`, which is responsible for the
      message being sent. If the `watch!` function is called more than once to watch
      the same actor, an exit message will be received several times, each one corresponding
      to an invocation of `watch!`, and each with a different value for `w`.
`actor` - the dead (watched) actor.
`cause` - the dead actor's cause of death: `nil` for a normal termination; a Throwable for
          an exceptional termination.

See: `unwatch!`, `link!`</pre></div><div class="public" id="var-whereis"><h3>whereis</h3><div class="usage"><code>(whereis actor-name)</code><code>(whereis actor-name timeout unit)</code></div><pre class="doc">Returns a registered actor by name, blocking until one is registered
</pre></div></div></body></html>