<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>co.paralleluniverse.pulsar.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Pulsar 0.5.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="co.paralleluniverse.pulsar.actors.html"><span>co.paralleluniverse.pulsar.actors</span></a></li><li><a href="co.paralleluniverse.pulsar.async.html"><span>co.paralleluniverse.pulsar.async</span></a></li><li class="current"><a href="co.paralleluniverse.pulsar.core.html"><span>co.paralleluniverse.pulsar.core</span></a></li><li><a href="co.paralleluniverse.pulsar.lazyseq.html"><span>co.paralleluniverse.pulsar.lazyseq</span></a></li><li><a href="co.paralleluniverse.pulsar.rx.html"><span>co.paralleluniverse.pulsar.rx</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="co.paralleluniverse.pulsar.core.html#var--%3Etimeunit"><span>-&gt;timeunit</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-alive%3F"><span>alive?</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-await"><span>await</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-channel"><span>channel</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-close%21"><span>close!</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-closed%3F"><span>closed?</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-convert-duration"><span>convert-duration</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-current-fiber"><span>current-fiber</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-current-strand"><span>current-strand</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-default-fiber-scheduler"><span>default-fiber-scheduler</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-defsfn"><span>defsfn</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-double-channel"><span>double-channel</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-fiber"><span>fiber</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-fiber-%3Efuture"><span>fiber-&gt;future</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-float-channel"><span>float-channel</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-int-channel"><span>int-channel</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-join"><span>join</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-letsfn"><span>letsfn</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-long-channel"><span>long-channel</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-promise"><span>promise</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-rcv-double"><span>rcv-double</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-rcv-float"><span>rcv-float</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-rcv-int"><span>rcv-int</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-rcv-long"><span>rcv-long</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-select"><span>select</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-seq-%3Echannel"><span>seq-&gt;channel</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-sfn"><span>sfn</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-singleton-channel"><span>singleton-channel</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-snd-double"><span>snd-double</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-snd-float"><span>snd-float</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-snd-int"><span>snd-int</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-snd-long"><span>snd-long</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-spawn-fiber"><span>spawn-fiber</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-spawn-thread"><span>spawn-thread</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-sreify"><span>sreify</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-start"><span>start</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-subscribe%21"><span>subscribe!</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-suspendable%21"><span>suspendable!</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-suspendable%3F"><span>suspendable?</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-ticker-consumer"><span>ticker-consumer</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-topic"><span>topic</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-try-rcv"><span>try-rcv</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-try-snd"><span>try-snd</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-try-snd-double"><span>try-snd-double</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-try-snd-float"><span>try-snd-float</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-try-snd-int"><span>try-snd-int</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-try-snd-long"><span>try-snd-long</span></a></li><li><a href="co.paralleluniverse.pulsar.core.html#var-unsubscribe%21"><span>unsubscribe!</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>co.paralleluniverse.pulsar.core documentation</h2><pre class="doc">Pulsar is an implementation of lightweight threads (fibers),
Go-like channles and Erlang-like actors for the JVM</pre><div class="public" id="var--%3Etimeunit"><h3>-&gt;timeunit</h3><div class="usage"><code>(-&gt;timeunit x)</code></div><pre class="doc">Constructs an instance of `java.util.concurrent.TimeUnit`.
If argument x is already an instance of `TimeUnit`, the function returns x.
Otherwise, x *must* be a keyword, in which case the following conversion
is performed:

:nanoseconds | :nanos | :ns   -&gt; TimeUnit/NANOSECONDS
:microseconds | :us           -&gt; TimeUnit/MICROSECONDS
:milliseconds | :millis | :ms -&gt; TimeUnit/MILLISECONDS
:seconds | :sec               -&gt; TimeUnit/SECONDS
:minutes | :mins              -&gt; TimeUnit/MINUTES
:hours | :hrs                 -&gt; TimeUnit/HOURS
:days                         -&gt; TimeUnit/DAYS
</pre></div><div class="public" id="var-alive%3F"><h3>alive?</h3><div class="usage"><code>(alive? a)</code></div><pre class="doc">Tests whether or not a strand is alive. 
A strand is alive if it has been started but has not yet died.</pre></div><div class="public" id="var-await"><h3>await</h3><h4 class="macro">macro</h4><div class="usage"><code>(await f &amp; args)</code></div><pre class="doc">Calls f, which takes a callback of a single argument as its last parameter,
with arguments args, and blocks the current fiber until the callback is called,
then returns the value passed to the callback.</pre></div><div class="public" id="var-channel"><h3>channel</h3><div class="usage"><code>(channel capacity overflow-policy)</code><code>(channel capacity)</code><code>(channel)</code></div><pre class="doc">Creates a new channel.

Optional arguments:
capacity        - specifies how many messages the channel can contain (until they are consumed)
                  * A value of `0` designates a *transfer channel*, that blocks both `snd` and `rcv` 
                    until a corresponding operation (`rcv` or `snd` respectively) is called.
                  * A value of `-1` creates an unbounded channel.

                  default: 0

overflow-policy - specifies what `snd` does when the channel's capacity is exhausted.
                  May be one of:
                  * :throw    - throws an exception.
                  * :block    - blocks until a message is consumed and room is available
                  * :drop     - the message is silently dropped
                  * :displace - the old message waiting in the queue is discarded to make room for the new message.
                  
                  default: :block

The default channel capacity is 0 and the default policy is :block</pre></div><div class="public" id="var-close%21"><h3>close!</h3><div class="usage"><code>(close! channel)</code><code>(close! channel exception)</code></div><pre class="doc">Closes a channel.
Messages already in the channel will be received, but all future attempts at `snd`
will silently discard the message. After all messages have been consumed, `rcv` will
return `nil`.

If an exception is passed as the second argument, then the same will happen, except after
all messages are consumed, the passed exception will be thrown by `rcv`, wrapped in a
`co.paralleluniverse.strands.channels.ProducerException`.</pre></div><div class="public" id="var-closed%3F"><h3>closed?</h3><div class="usage"><code>(closed? channel)</code></div><pre class="doc">Tests whether a channel has been closed and contains no more messages that 
can be received.</pre></div><div class="public" id="var-convert-duration"><h3>convert-duration</h3><div class="usage"><code>(convert-duration x from-unit to-unit)</code></div><pre class="doc">Converts a time duration from one time unit to another.
x is the duration; `from-unit` and `to-unit` are the source
and target units repsectively, given as either a j.u.c.TimeUnit instance
or as a keyword, as specified by `-&gt;timeunit`.</pre></div><div class="public" id="var-current-fiber"><h3>current-fiber</h3><div class="usage"><code>(current-fiber)</code></div><pre class="doc">Returns the currently running lightweight-thread or `nil` if none.
</pre></div><div class="public" id="var-current-strand"><h3>current-strand</h3><div class="usage"><code>(current-strand)</code></div><pre class="doc">Returns the currently running fiber (if running in fiber)
or current thread (if not).</pre></div><div class="public" id="var-default-fiber-scheduler"><h3>default-fiber-scheduler</h3><div class="usage"></div><pre class="doc">A global fiber scheduler. The scheduler uses all available processor cores.
</pre></div><div class="public" id="var-defsfn"><h3>defsfn</h3><h4 class="macro">macro</h4><div class="usage"><code>(defsfn &amp; expr)</code></div><pre class="doc">Defines a suspendable function that can be used by a fiber or actor.
Used exactly like `defn`</pre></div><div class="public" id="var-double-channel"><h3>double-channel</h3><div class="usage"><code>(double-channel size overflow-policy)</code><code>(double-channel size)</code><code>(double-channel)</code></div><pre class="doc">Creates a double channel
</pre></div><div class="public" id="var-fiber"><h3>fiber</h3><div class="usage"><code>(fiber &amp; args)</code></div><pre class="doc">Creates, but does not start a new fiber (a lightweight thread) running in a fork/join pool.

It is much preferable to use `spawn-fiber`.</pre></div><div class="public" id="var-fiber-%3Efuture"><h3>fiber-&gt;future</h3><div class="usage"><code>(fiber-&gt;future f)</code></div><pre class="doc">Takes a spawned fiber yields a future object that will
invoke the function in another thread, and will cache the result and
return it on all subsequent calls to deref/@. If the computation has
not yet finished, calls to deref/@ will block, unless the variant
of deref with timeout is used. See also - realized?.</pre></div><div class="public" id="var-float-channel"><h3>float-channel</h3><div class="usage"><code>(float-channel size overflow-policy)</code><code>(float-channel size)</code><code>(float-channel)</code></div><pre class="doc">Creates a float channel
</pre></div><div class="public" id="var-int-channel"><h3>int-channel</h3><div class="usage"><code>(int-channel size overflow-policy)</code><code>(int-channel size)</code><code>(int-channel)</code></div><pre class="doc">Creates an int channel
</pre></div><div class="public" id="var-join"><h3>join</h3><div class="usage"><code>(join s)</code><code>(join timeout unit s)</code></div><pre class="doc">Awaits the termination of the given strand or strands, and returns
their result, if applicable.

If a single strand is given, its result is returned;
if a collection - then a collection of the repsective results.

Note that for threads, the result is always `nil`, as threads don't return a value.

If a timeout is supplied and it elapses before the strand has terminated,
a j.u.c.TimeoutException is thrown.

s       - either a strand or a collection of strands.
timeout - how long to wait for the strands termination
unit    - the unit of the timeout duration. TimeUnit or keyword as in `-&gt;timeunit`</pre></div><div class="public" id="var-letsfn"><h3>letsfn</h3><h4 class="macro">macro</h4><div class="usage"><code>(letsfn fnspecs &amp; body)</code></div><pre class="doc">Defines a local suspendable function that can be used by a fiber or actor.
Used exactly like `letfn`</pre></div><div class="public" id="var-long-channel"><h3>long-channel</h3><div class="usage"><code>(long-channel size overflow-policy)</code><code>(long-channel size)</code><code>(long-channel)</code></div><pre class="doc">Creates a long channel
</pre></div><div class="public" id="var-promise"><h3>promise</h3><div class="usage"><code>(promise f)</code><code>(promise)</code></div><pre class="doc">Returns a promise object that can be read with deref/@, and set,
once only, with deliver. Calls to deref/@ prior to delivery will
block, unless the variant of deref with timeout is used. All
subsequent derefs will return the same delivered value without
blocking. See also - realized?.

Unlike clojure.core/promise, this promise object can be used inside Pulsar fibers.</pre></div><div class="public" id="var-rcv-double"><h3>rcv-double</h3><h4 class="macro">macro</h4><div class="usage"><code>(rcv-double channel)</code><code>(rcv-double channel timeout unit)</code></div><pre class="doc">Receives a double value from a double-channel.

See: `rcv`</pre></div><div class="public" id="var-rcv-float"><h3>rcv-float</h3><h4 class="macro">macro</h4><div class="usage"><code>(rcv-float channel)</code><code>(rcv-float channel timeout unit)</code></div><pre class="doc">Receives a float value from a float-channel.

See: `rcv`</pre></div><div class="public" id="var-rcv-int"><h3>rcv-int</h3><h4 class="macro">macro</h4><div class="usage"><code>(rcv-int channel)</code><code>(rcv-int channel timeout unit)</code></div><pre class="doc">Receives an int value from an int-channel.

See: `rcv`</pre></div><div class="public" id="var-rcv-long"><h3>rcv-long</h3><h4 class="macro">macro</h4><div class="usage"><code>(rcv-long channel)</code><code>(rcv-long channel timeout unit)</code></div><pre class="doc">Receives a long value from a long-channel.

See: `rcv`</pre></div><div class="public" id="var-select"><h3>select</h3><h4 class="macro">macro</h4><div class="usage"><code>(select &amp; clauses)</code></div><pre class="doc">Performs a very similar operation to `sel`, but allows you to specify an action to perform depending 
on which operation has succeeded.
Takes an even number of expressions, ordered as (ops1, action1, ops2, action2 ...) with the ops being 
a channel operation descriptior (remember: a descriptor is either a channel for an `rcv` operation, 
or a vector of a channel and a message specifying a `snd` operation) or a collection of descriptors, 
and the actions are Clojure expressions. 
Like `sel`, `select` performs at most one operation, in which case it will run the operation's 
respective action and return its result.

An action expression can bind values to the operations results. 
The action expression may begin with a vector of one or two symbols. In that case, the first symbol 
will be bound to the message returned from the successful receive in the respective ops clause 
(or `nil` if the successful operation is a `snd`), and the second symbol, if present, will be bound 
to the successful operation's channel.

Like `sel`, `select` blocks until an operation succeeds, or, if a `:timeout` option is specified, 
until the timeout (in milliseconds) elapses. If a timeout is specfied and elapses, `select` will run 
the action in an optional `:else` clause and return its result, or, if an `:else` clause is not present, 
`select` will return `nil`.

Example:

(select :timeout 100 
       c1 ([v] (println &quot;received&quot; v))
       [[c2 m2] [c3 m3]] ([v c] (println &quot;sent to&quot; c))
       :else &quot;timeout!&quot;)

In the example, if a message is received from channel `c1`, then it will be printed. 
If a message is sent to either `c2` or `c3`, then the identity of the channel will be printed, 
and if the 100 ms timeout elapses then &quot;timeout!&quot; will be printed.</pre></div><div class="public" id="var-seq-%3Echannel"><h3>seq-&gt;channel</h3><div class="usage"><code>(seq-&gt;channel x)</code></div><pre class="doc">Turns a sequence into a receive port that receives all values in the sequence
</pre></div><div class="public" id="var-sfn"><h3>sfn</h3><h4 class="macro">macro</h4><div class="usage"><code>(sfn &amp; expr)</code></div><pre class="doc">Creates a suspendable function that can be used by a fiber or actor.
Used exactly like `fn`</pre></div><div class="public" id="var-singleton-channel"><h3>singleton-channel</h3><div class="usage"><code>(singleton-channel x)</code></div><pre class="doc">Returns a channel that receives a single, given value
and then closes</pre></div><div class="public" id="var-snd-double"><h3>snd-double</h3><h4 class="macro">macro</h4><div class="usage"><code>(snd-double channel message)</code></div><pre class="doc">Sends a double value to a double-channel.  

See: `snd`</pre></div><div class="public" id="var-snd-float"><h3>snd-float</h3><h4 class="macro">macro</h4><div class="usage"><code>(snd-float channel message)</code></div><pre class="doc">Sends a float value to a float-channel.  

See: `snd`</pre></div><div class="public" id="var-snd-int"><h3>snd-int</h3><h4 class="macro">macro</h4><div class="usage"><code>(snd-int channel message)</code></div><pre class="doc">Sends an int value to an int-channel.

See: `snd`</pre></div><div class="public" id="var-snd-long"><h3>snd-long</h3><h4 class="macro">macro</h4><div class="usage"><code>(snd-long channel message)</code></div><pre class="doc">Sends a long value to a long-channel.  

See: `snd`</pre></div><div class="public" id="var-spawn-fiber"><h3>spawn-fiber</h3><h4 class="macro">macro</h4><div class="usage"><code>(spawn-fiber :name? :stack-size? :scheduler? f &amp; args)</code></div><pre class="doc">Creates and starts a new fiber.

f - the function to run in the fiber.
args - (optional) arguments for the function

Options:
:name str     - the fiber's name
:stack-size n - the fiber's initial stack size
:scheduler    - the fiber schdeuler in which the fiber will run
</pre></div><div class="public" id="var-spawn-thread"><h3>spawn-thread</h3><div class="usage"><code>(spawn-thread :name? f &amp; args)</code></div><pre class="doc">Creates and starts a new thread.

f - the function to run in the thread.
args - (optional) arguments to pass to the function

Options:
:name str     - the thread's name</pre></div><div class="public" id="var-sreify"><h3>sreify</h3><h4 class="macro">macro</h4><div class="usage"><code>(sreify &amp; expr)</code></div><pre class="doc">Creates a suspendable implementation of a protocol or interface.
sreify is to reify what sfn is to fn.</pre></div><div class="public" id="var-start"><h3>start</h3><div class="usage"><code>(start fiber)</code></div><pre class="doc">Starts a fiber created with `fiber`.
</pre></div><div class="public" id="var-subscribe%21"><h3>subscribe!</h3><div class="usage"><code>(subscribe! topic channel)</code></div><pre class="doc">Subscribes a channel to a topic.
The subscribed channel will receive all messages sent to the topic.</pre></div><div class="public" id="var-suspendable%21"><h3>suspendable!</h3><div class="usage"><code>(suspendable! f)</code><code>(suspendable! x prot)</code></div><pre class="doc">Makes a function suspendable.
</pre></div><div class="public" id="var-suspendable%3F"><h3>suspendable?</h3><div class="usage"><code>(suspendable? f)</code></div><pre class="doc">Returns true of a function has been instrumented as suspendable; false otherwise.
</pre></div><div class="public" id="var-ticker-consumer"><h3>ticker-consumer</h3><div class="usage"><code>(ticker-consumer ticker)</code></div><pre class="doc">Creates a rcv-port (read-only channel) that returns messages from a *ticker channel*.
A ticker channel is a bounded channel with an overflow policy of :displace.

Different ticker consumers are independent (a message received from one is not removed from others),
and guarantee monotonicty (messages are received in order), but if messages are sent to the
ticker channel faster than they are consumed then messages can be lost.</pre></div><div class="public" id="var-topic"><h3>topic</h3><div class="usage"><code>(topic)</code></div><pre class="doc">Creates a new topic.
A topic is a send-port (a write-only channel) that forwards every message sent to it
to a group of subscribed channels.
Use `subscribe!` and `unsubscribe!` to subscribe and unsubscribe a channel to or from
the topic.</pre></div><div class="public" id="var-try-rcv"><h3>try-rcv</h3><div class="usage"><code>(try-rcv channel)</code></div><pre class="doc">Attempts to immediately (without blocking) receive a message from a channel.
Returns the message if one is immediately available; `nil` otherwise.
This function never blocks.</pre></div><div class="public" id="var-try-snd"><h3>try-snd</h3><div class="usage"><code>(try-snd channel message)</code></div><pre class="doc">Tries to immediately send a message to a channel.
If the channel's capacity is exceeded, this function fails and returns `false`.
Returns `true` if the operation succeeded; `false` otherwise.
This function never blocks.</pre></div><div class="public" id="var-try-snd-double"><h3>try-snd-double</h3><h4 class="macro">macro</h4><div class="usage"><code>(try-snd-double channel message)</code></div><pre class="doc">Tries to immediately send a double value to a double-channel.
Returns `true` if successful, `false` otherwise.  

See: `try-snd`</pre></div><div class="public" id="var-try-snd-float"><h3>try-snd-float</h3><h4 class="macro">macro</h4><div class="usage"><code>(try-snd-float channel message)</code></div><pre class="doc">Tries to immediately send a float value to a float-channel.
Returns `true` if successful, `false` otherwise.  

See: `try-snd`</pre></div><div class="public" id="var-try-snd-int"><h3>try-snd-int</h3><h4 class="macro">macro</h4><div class="usage"><code>(try-snd-int channel message)</code></div><pre class="doc">Tries to immediately send an int value to an int-channel.
Returns `true` if successful, `false` otherwise.

See: `try-snd`</pre></div><div class="public" id="var-try-snd-long"><h3>try-snd-long</h3><h4 class="macro">macro</h4><div class="usage"><code>(try-snd-long channel message)</code></div><pre class="doc">Tries to immediately send a long value to a long-channel.
Returns `true` if successful, `false` otherwise.  

See: `try-snd`</pre></div><div class="public" id="var-unsubscribe%21"><h3>unsubscribe!</h3><div class="usage"><code>(unsubscribe! topic channel)</code></div><pre class="doc">Unsubscribes a channel from a topic.
The channel will stop receiving messages sent to the topic.</pre></div></div></body></html>